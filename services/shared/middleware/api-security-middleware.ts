/**
 * Comprehensive API Security Middleware
 * 
 * Addresses multiple security requirements:
 * - API Versioning (/v1 prefix)
 * - Input validation with zod schemas
 * - SSRF protection for URLs
 * - Enhanced rate limiting per tenant/user
 * - CORS restrictions per environment
 * - Secure cookie configuration
 */

import { Request, Response, NextFunction } from 'express';
import cors from 'cors';
import rateLimit from 'express-rate-limit';
import { z } from 'zod';
import dns from 'dns';
import { promisify } from 'util';
import net from 'net';
import winston from 'winston';

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.json()
  ),
  transports: [
    new winston.transports.Console()
  ]
});

const dnsLookup = promisify(dns.lookup);

// =============================================================================
// Task 14: API Versioning
// =============================================================================

/**
 * API versioning middleware - ensures all routes use /v1 prefix
 */
export function apiVersioning() {
  return (req: Request, res: Response, next: NextFunction): void => {
    // Allow health check and metrics without versioning
    if (['/health', '/metrics'].includes(req.path)) {
      next();
      return;
    }
    
    // Redirect non-versioned API calls to v1
    if (req.path.startsWith('/api/') && !req.path.startsWith('/api/v1/')) {
      const versionedPath = req.path.replace('/api/', '/api/v1/');
      res.redirect(301, versionedPath);
      return;
    }
    
    // Ensure v1 is the current version
    if (req.path.startsWith('/api/v1/')) {
      req.url = req.url.replace('/api/v1/', '/api/');
      req.path = req.path.replace('/api/v1/', '/api/');
    }
    
    next();
  };\n}\n\n// =============================================================================\n// Task 15: Input Validation\n// =============================================================================\n\n// Common validation schemas\nconst commonSchemas = {\n  // ID validation\n  id: z.string().min(1).max(255).regex(/^[a-zA-Z0-9_-]+$/, 'Invalid ID format'),\n  \n  // Email validation\n  email: z.string().email().max(320),\n  \n  // Tenant ID validation\n  tenantId: z.string().min(3).max(50).regex(/^[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9]$/, 'Invalid tenant ID'),\n  \n  // User ID validation\n  userId: z.string().min(1).max(255).regex(/^[a-zA-Z0-9_.-]+$/, 'Invalid user ID'),\n  \n  // Name validation (limited length)\n  name: z.string().min(1).max(200).trim(),\n  \n  // Prompt validation (with length limits)\n  prompt: z.string().min(1).max(8000).trim(),\n  \n  // URL validation\n  url: z.string().url().max(2048),\n  \n  // Pagination\n  pagination: z.object({\n    limit: z.number().int().min(1).max(100).default(50),\n    offset: z.number().int().min(0).default(0)\n  })\n};\n\n/**\n * Request DTO validation schemas\n */\nexport const ValidationSchemas = {\n  // Workspace creation\n  createWorkspace: z.object({\n    body: z.object({\n      name: commonSchemas.name,\n      description: z.string().max(1000).optional(),\n      goals: z.record(z.any()).optional(),\n      budget: z.object({\n        total_usd: z.number().positive().max(1000000)\n      }).optional()\n    })\n  }),\n  \n  // Model registration\n  registerModel: z.object({\n    body: z.object({\n      name: commonSchemas.name,\n      version: z.string().min(1).max(50),\n      provider: z.enum(['openai', 'anthropic', 'azure', 'custom']),\n      modelType: z.enum(['chat', 'completion', 'embedding', 'image', 'audio']),\n      capabilities: z.array(z.string()).max(20),\n      parameters: z.record(z.any()),\n      endpoint: commonSchemas.url.optional()\n    })\n  }),\n  \n  // User input with prompt\n  promptRequest: z.object({\n    body: z.object({\n      prompt: commonSchemas.prompt,\n      model: commonSchemas.name.optional(),\n      parameters: z.record(z.any()).optional()\n    })\n  }),\n  \n  // DSR requests\n  dsrRequest: z.object({\n    body: z.object({\n      userId: commonSchemas.userId,\n      tenantId: commonSchemas.tenantId,\n      userEmail: commonSchemas.email,\n      requestedBy: commonSchemas.userId,\n      reason: z.string().min(10).max(1000).optional(),\n      verificationToken: z.string().min(32).max(512)\n    })\n  })\n};\n\n/**\n * Validation middleware factory\n */\nexport function validateSchema(schema: z.ZodSchema) {\n  return (req: Request, res: Response, next: NextFunction): void => {\n    try {\n      const validated = schema.parse({\n        body: req.body,\n        query: req.query,\n        params: req.params\n      });\n      \n      // Replace request data with validated data\n      req.body = validated.body || req.body;\n      req.query = validated.query || req.query;\n      req.params = validated.params || req.params;\n      \n      next();\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        logger.warn('Validation failed', {\n          path: req.path,\n          errors: error.errors,\n          ip: req.ip\n        });\n        \n        res.status(400).json({\n          error: 'Validation failed',\n          code: 'VALIDATION_ERROR',\n          details: error.errors.map(err => ({\n            field: err.path.join('.'),\n            message: err.message,\n            code: err.code\n          }))\n        });\n        return;\n      }\n      \n      next(error);\n    }\n  };\n}\n\n// =============================================================================\n// Task 16: SSRF Protection\n// =============================================================================\n\n// Private IP ranges to block\nconst PRIVATE_IP_RANGES = [\n  '10.0.0.0/8',\n  '172.16.0.0/12',\n  '192.168.0.0/16',\n  '127.0.0.0/8',\n  '169.254.0.0/16', // Link-local\n  '::1/128', // IPv6 loopback\n  'fc00::/7', // IPv6 unique local\n  'fe80::/10' // IPv6 link-local\n];\n\n// Allowed URL schemes\nconst ALLOWED_SCHEMES = ['http:', 'https:'];\n\n// Allowed hosts (configurable per environment)\nconst ALLOWED_HOSTS = (\n  process.env.ALLOWED_EXTERNAL_HOSTS || \n  'api.openai.com,api.anthropic.com,api.azure.com'\n).split(',');\n\n/**\n * Check if IP is private\n */\nfunction isPrivateIP(ip: string): boolean {\n  // Simple check for common private ranges\n  return (\n    ip.startsWith('10.') ||\n    ip.startsWith('192.168.') ||\n    ip.startsWith('172.') ||\n    ip.startsWith('127.') ||\n    ip.startsWith('169.254.') ||\n    ip === '::1' ||\n    ip.startsWith('fc') ||\n    ip.startsWith('fe80')\n  );\n}\n\n/**\n * SSRF protection for URL validation\n */\nexport async function validateUrl(url: string): Promise<{ \n  isValid: boolean; \n  error?: string; \n}> {\n  try {\n    const parsed = new URL(url);\n    \n    // Check scheme\n    if (!ALLOWED_SCHEMES.includes(parsed.protocol)) {\n      return {\n        isValid: false,\n        error: `Scheme '${parsed.protocol}' not allowed`\n      };\n    }\n    \n    // Check host allowlist\n    if (!ALLOWED_HOSTS.includes(parsed.hostname)) {\n      return {\n        isValid: false,\n        error: `Host '${parsed.hostname}' not in allowlist`\n      };\n    }\n    \n    // DNS resolution and IP validation\n    try {\n      const { address } = await dnsLookup(parsed.hostname);\n      \n      if (isPrivateIP(address)) {\n        return {\n          isValid: false,\n          error: `Host resolves to private IP: ${address}`\n        };\n      }\n    } catch (dnsError) {\n      return {\n        isValid: false,\n        error: `DNS resolution failed: ${dnsError}`\n      };\n    }\n    \n    return { isValid: true };\n  } catch (error) {\n    return {\n      isValid: false,\n      error: `Invalid URL: ${error}`\n    };\n  }\n}\n\n/**\n * SSRF protection middleware\n */\nexport function ssrfProtection() {\n  return async (req: Request, res: Response, next: NextFunction): Promise<void> => {\n    // Check for URLs in request body\n    const urls: string[] = [];\n    \n    function extractUrls(obj: any, path = ''): void {\n      if (typeof obj === 'string' && obj.match(/^https?:\\/\\//)) {\n        urls.push(obj);\n      } else if (Array.isArray(obj)) {\n        obj.forEach((item, index) => extractUrls(item, `${path}[${index}]`));\n      } else if (obj && typeof obj === 'object') {\n        Object.keys(obj).forEach(key => {\n          extractUrls(obj[key], path ? `${path}.${key}` : key);\n        });\n      }\n    }\n    \n    extractUrls(req.body);\n    \n    // Validate all found URLs\n    for (const url of urls) {\n      const validation = await validateUrl(url);\n      if (!validation.isValid) {\n        logger.warn('SSRF protection blocked request', {\n          url,\n          error: validation.error,\n          ip: req.ip,\n          path: req.path\n        });\n        \n        res.status(400).json({\n          error: 'Invalid URL detected',\n          code: 'SSRF_PROTECTION',\n          details: validation.error\n        });\n        return;\n      }\n    }\n    \n    next();\n  };\n}\n\n// =============================================================================\n// Task 17: Enhanced Rate Limiting\n// =============================================================================\n\n/**\n * Enhanced rate limiting per tenant/user\n */\nexport function enhancedRateLimit() {\n  return rateLimit({\n    windowMs: 15 * 60 * 1000, // 15 minutes\n    \n    // Dynamic limit based on user context\n    max: (req: Request) => {\n      const user = (req as any).user;\n      \n      // Higher limits for admin users\n      if (user?.roles?.includes('admin')) {\n        return 2000;\n      }\n      \n      // Normal user limits\n      return 1000;\n    },\n    \n    // Key generator for per-tenant/user limiting\n    keyGenerator: (req: Request) => {\n      const user = (req as any).user;\n      \n      if (user) {\n        return `${user.tenantId}:${user.userId}`;\n      }\n      \n      // Fallback to IP\n      return req.ip;\n    },\n    \n    // Custom handler\n    handler: (req: Request, res: Response) => {\n      const user = (req as any).user;\n      \n      logger.warn('Rate limit exceeded', {\n        tenantId: user?.tenantId,\n        userId: user?.userId,\n        ip: req.ip,\n        path: req.path\n      });\n      \n      res.status(429).json({\n        error: 'Rate limit exceeded',\n        code: 'RATE_LIMIT_EXCEEDED',\n        retryAfter: 15 * 60 // 15 minutes\n      });\n    },\n    \n    standardHeaders: true,\n    legacyHeaders: false\n  });\n}\n\n/**\n * Request body size limiter\n */\nexport function bodySizeLimit() {\n  return (req: Request, res: Response, next: NextFunction): void => {\n    const contentLength = parseInt(req.headers['content-length'] || '0');\n    const maxSize = 10 * 1024 * 1024; // 10MB\n    \n    if (contentLength > maxSize) {\n      res.status(413).json({\n        error: 'Request body too large',\n        code: 'BODY_TOO_LARGE',\n        maxSize: `${maxSize / 1024 / 1024}MB`\n      });\n      return;\n    }\n    \n    next();\n  };\n}\n\n// =============================================================================\n// Task 18: CORS Restrictions\n// =============================================================================\n\n/**\n * Environment-specific CORS configuration\n */\nexport function corsRestriction() {\n  const environment = process.env.NODE_ENV || 'development';\n  \n  let allowedOrigins: string[];\n  \n  switch (environment) {\n    case 'production':\n      allowedOrigins = [\n        'https://smm-architect.com',\n        'https://app.smm-architect.com',\n        'https://admin.smm-architect.com'\n      ];\n      break;\n    case 'staging':\n      allowedOrigins = [\n        'https://staging.smm-architect.com',\n        'https://staging-app.smm-architect.com'\n      ];\n      break;\n    default:\n      allowedOrigins = [\n        'http://localhost:3000',\n        'http://localhost:3001',\n        'http://localhost:8080'\n      ];\n  }\n  \n  // Add environment-specific origins\n  const envOrigins = process.env.CORS_ORIGINS?.split(',') || [];\n  allowedOrigins.push(...envOrigins);\n  \n  return cors({\n    origin: (origin, callback) => {\n      // Allow requests with no origin (mobile apps, etc.)\n      if (!origin) {\n        callback(null, true);\n        return;\n      }\n      \n      if (allowedOrigins.includes(origin)) {\n        callback(null, true);\n      } else {\n        logger.warn('CORS blocked request', {\n          origin,\n          allowedOrigins,\n          environment\n        });\n        \n        callback(new Error('Not allowed by CORS'));\n      }\n    },\n    credentials: true,\n    optionsSuccessStatus: 200,\n    methods: ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'OPTIONS'],\n    allowedHeaders: [\n      'Content-Type',\n      'Authorization',\n      'X-Tenant-ID',\n      'X-API-Key',\n      'Idempotency-Key'\n    ],\n    exposedHeaders: [\n      'X-Rate-Limit-Limit',\n      'X-Rate-Limit-Remaining',\n      'X-Idempotency-Replay'\n    ]\n  });\n}\n\n// =============================================================================\n// Task 19: Secure Cookies\n// =============================================================================\n\n/**\n * Secure cookie configuration middleware\n */\nexport function secureCookies() {\n  return (req: Request, res: Response, next: NextFunction): void => {\n    const originalCookie = res.cookie.bind(res);\n    \n    res.cookie = (name: string, value: any, options: any = {}) => {\n      const secureOptions = {\n        ...options,\n        httpOnly: true, // Prevent XSS\n        secure: process.env.NODE_ENV === 'production', // HTTPS only in production\n        sameSite: 'lax' as const, // CSRF protection\n        maxAge: options.maxAge || 24 * 60 * 60 * 1000, // 24 hours default\n        path: options.path || '/',\n        domain: options.domain || undefined\n      };\n      \n      // Use 'strict' for sensitive cookies\n      if (name.includes('auth') || name.includes('session') || name.includes('csrf')) {\n        secureOptions.sameSite = 'strict';\n      }\n      \n      return originalCookie(name, value, secureOptions);\n    };\n    \n    next();\n  };\n}\n\n// =============================================================================\n// Combined Security Middleware\n// =============================================================================\n\n/**\n * Apply all API security middleware in correct order\n */\nexport function apiSecurityMiddleware() {\n  return [\n    bodySizeLimit(),\n    corsRestriction(),\n    secureCookies(),\n    apiVersioning(),\n    enhancedRateLimit(),\n    ssrfProtection()\n  ];\n}\n\nexport default {\n  apiVersioning,\n  validateSchema,\n  ValidationSchemas,\n  ssrfProtection,\n  validateUrl,\n  enhancedRateLimit,\n  bodySizeLimit,\n  corsRestriction,\n  secureCookies,\n  apiSecurityMiddleware\n};", "original_text": ""}]