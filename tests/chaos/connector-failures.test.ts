import { describe, it, expect, beforeAll, afterAll, beforeEach, afterEach } from '@jest/globals';
import nock from 'nock';
import { PublisherAgent } from '../src/agents/publisher-agent';
import { ConnectorManager } from '../src/services/connector-manager';
import { DecisionCardService } from '../src/services/decision-card-service';
import { 
  ConnectorFailureSimulator, 
  FaultInjectionScenario,
  ConnectorStatus,
  PlatformError 
} from '../src/testing/chaos-engineering';

describe('Chaos Engineering - Connector Failures', () => {
  let publisherAgent: PublisherAgent;
  let connectorManager: ConnectorManager;
  let decisionCardService: DecisionCardService;
  let chaosSimulator: ConnectorFailureSimulator;

  beforeAll(() => {
    publisherAgent = new PublisherAgent();
    connectorManager = new ConnectorManager();
    decisionCardService = new DecisionCardService();
    chaosSimulator = new ConnectorFailureSimulator();
  });

  beforeEach(() => {
    // Clear any existing nock interceptors
    nock.cleanAll();
  });

  afterEach(() => {
    nock.cleanAll();
  });

  afterAll(() => {
    nock.restore();
  });

  describe('Token Expiry Cascade Failures', () => {
    it('should handle LinkedIn token expiry with exponential backoff', async () => {
      const scenario: FaultInjectionScenario = {\n        name: 'linkedin-token-expiry-cascade',\n        platform: 'linkedin',\n        sequence: [\n          {\n            step: 1,\n            httpStatus: 401,\n            error: {\n              code: 'UNAUTHORIZED',\n              message: 'Access token expired',\n              details: { tokenExpiredAt: '2024-01-15T10:30:00Z' }\n            },\n            delay: 0\n          },\n          {\n            step: 2,\n            httpStatus: 429,\n            error: {\n              code: 'RATE_LIMITED',\n              message: 'Too many token refresh attempts',\n              details: { retryAfter: 60 }\n            },\n            delay: 1000\n          },\n          {\n            step: 3,\n            httpStatus: 200,\n            response: {\n              id: 'urn:li:activity:7123456789',\n              publishedAt: '2024-01-15T10:35:00Z',\n              status: 'published'\n            },\n            delay: 2000\n          }\n        ],\n        expectedBehavior: {\n          maxRetries: 3,\n          backoffStrategy: 'exponential',\n          fallbackActivated: true,\n          decisionCardGenerated: true,\n          auditTrailComplete: true\n        }\n      };\n\n      // Setup mock responses based on scenario\n      let callCount = 0;\n      nock('https://api.linkedin.com')\n        .persist()\n        .post('/v2/ugcPosts')\n        .reply(() => {\n          callCount++;\n          const step = scenario.sequence.find(s => s.step === callCount);\n          if (step) {\n            if (step.httpStatus === 200) {\n              return [step.httpStatus, step.response];\n            } else {\n              return [step.httpStatus, step.error];\n            }\n          }\n          return [500, { error: 'Unexpected call' }];\n        });\n\n      // Inject chaos scenario\n      await chaosSimulator.injectScenario(scenario);\n\n      const publishRequest = {\n        workspaceId: 'ws-test-001',\n        platform: 'linkedin',\n        content: {\n          text: 'Test post for chaos engineering',\n          media: []\n        },\n        scheduledTime: new Date('2024-01-15T10:30:00Z')\n      };\n\n      const result = await publisherAgent.publish(publishRequest);\n\n      // Verify expected behavior\n      expect(result.status).toBe('published');\n      expect(result.retries).toBe(3);\n      expect(result.fallbackUsed).toBe(true);\n      expect(result.publishedAt).toBeDefined();\n\n      // Verify decision card was generated\n      const decisionCards = await decisionCardService.getByWorkspace('ws-test-001');\n      const tokenExpiryCard = decisionCards.find(card => \n        card.recommendations.some(rec => rec.includes('reconnect_linkedin'))\n      );\n      expect(tokenExpiryCard).toBeDefined();\n\n      // Verify audit trail\n      expect(result.auditTrail).toHaveLength(3); // Initial attempt + 2 retries\n      expect(result.auditTrail[0].error).toContain('Access token expired');\n      expect(result.auditTrail[1].error).toContain('Rate limited');\n      expect(result.auditTrail[2].status).toBe('success');\n    });\n\n    it('should activate browser fallback when all API attempts fail', async () => {\n      const scenario: FaultInjectionScenario = {\n        name: 'total-api-failure',\n        platform: 'linkedin',\n        sequence: [\n          { step: 1, httpStatus: 401, error: { code: 'UNAUTHORIZED' }, delay: 0 },\n          { step: 2, httpStatus: 429, error: { code: 'RATE_LIMITED' }, delay: 1000 },\n          { step: 3, httpStatus: 503, error: { code: 'SERVICE_UNAVAILABLE' }, delay: 2000 },\n          { step: 4, httpStatus: 500, error: { code: 'INTERNAL_ERROR' }, delay: 4000 }\n        ],\n        expectedBehavior: {\n          maxRetries: 4,\n          fallbackToBrowser: true,\n          decisionCardGenerated: true\n        }\n      };\n\n      nock('https://api.linkedin.com')\n        .persist()\n        .post('/v2/ugcPosts')\n        .reply((uri, requestBody) => {\n          const step = scenario.sequence.find(s => s.step <= 4);\n          return [step?.httpStatus || 500, step?.error || { error: 'Unknown error' }];\n        });\n\n      await chaosSimulator.injectScenario(scenario);\n\n      const publishRequest = {\n        workspaceId: 'ws-test-001',\n        platform: 'linkedin',\n        content: {\n          text: 'Test post requiring browser fallback'\n        },\n        allowBrowserFallback: true\n      };\n\n      const result = await publisherAgent.publish(publishRequest);\n\n      // Should fallback to browser automation\n      expect(result.status).toBe('queued_for_browser');\n      expect(result.fallbackMethod).toBe('playwright');\n      expect(result.apiAttempts).toBe(4);\n\n      // Verify decision card recommendations\n      const decisionCards = await decisionCardService.getByWorkspace('ws-test-001');\n      const fallbackCard = decisionCards.find(card => \n        card.recommendations.some(rec => rec.includes('browser_fallback_activated'))\n      );\n      expect(fallbackCard).toBeDefined();\n      expect(fallbackCard?.metadata.fallbackReason).toBe('api_exhausted');\n    });\n  });\n\n  describe('Rate Limiting Chaos', () => {\n    it('should handle cascading rate limits across multiple platforms', async () => {\n      const multiPlatformScenario: FaultInjectionScenario = {\n        name: 'multi-platform-rate-limit',\n        platform: 'all',\n        sequence: [\n          {\n            step: 1,\n            platforms: ['linkedin', 'x', 'instagram'],\n            httpStatus: 429,\n            error: {\n              code: 'RATE_LIMITED',\n              message: 'Rate limit exceeded',\n              details: { retryAfter: 300, limitType: 'burst' }\n            }\n          }\n        ],\n        expectedBehavior: {\n          gracefulDegradation: true,\n          redistributeLoad: true,\n          decisionCardGenerated: true\n        }\n      };\n\n      // Mock all platform APIs with rate limiting\n      nock('https://api.linkedin.com')\n        .post('/v2/ugcPosts')\n        .reply(429, {\n          error: 'Rate limit exceeded',\n          retryAfter: 300\n        });\n\n      nock('https://api.twitter.com')\n        .post('/2/tweets')\n        .reply(429, {\n          error: 'Rate limit exceeded',\n          retryAfter: 900\n        });\n\n      nock('https://graph.facebook.com')\n        .post('/me/media')\n        .reply(429, {\n          error: 'Application request limit reached',\n          retryAfter: 1800\n        });\n\n      await chaosSimulator.injectScenario(multiPlatformScenario);\n\n      const campaignRequest = {\n        workspaceId: 'ws-test-001',\n        platforms: ['linkedin', 'x', 'instagram'],\n        content: {\n          text: 'Multi-platform campaign test'\n        },\n        distributionStrategy: 'adaptive'\n      };\n\n      const result = await publisherAgent.publishToCampaign(campaignRequest);\n\n      // Verify graceful degradation\n      expect(result.overallStatus).toBe('partially_successful');\n      expect(result.platformResults.every(pr => pr.status === 'rate_limited')).toBe(true);\n      expect(result.redistributionApplied).toBe(true);\n\n      // Verify load redistribution decision\n      const decisionCards = await decisionCardService.getByWorkspace('ws-test-001');\n      const redistributionCard = decisionCards.find(card => \n        card.recommendations.some(rec => rec.includes('redistribute_campaign_load'))\n      );\n      expect(redistributionCard).toBeDefined();\n      expect(redistributionCard?.metadata.affectedPlatforms).toHaveLength(3);\n    });\n\n    it('should implement exponential backoff with jitter', async () => {\n      const backoffScenario: FaultInjectionScenario = {\n        name: 'rate-limit-backoff-test',\n        platform: 'x',\n        sequence: [\n          { step: 1, httpStatus: 429, error: { retryAfter: 60 }, delay: 0 },\n          { step: 2, httpStatus: 429, error: { retryAfter: 120 }, delay: 60000 },\n          { step: 3, httpStatus: 429, error: { retryAfter: 240 }, delay: 120000 },\n          { step: 4, httpStatus: 200, response: { id: '1234567890' }, delay: 240000 }\n        ],\n        expectedBehavior: {\n          backoffStrategy: 'exponential_with_jitter',\n          maxBackoffTime: 300000,\n          jitterRange: 0.1\n        }\n      };\n\n      let attemptTimes: number[] = [];\n      \n      nock('https://api.twitter.com')\n        .persist()\n        .post('/2/tweets')\n        .reply(() => {\n          attemptTimes.push(Date.now());\n          const attempt = attemptTimes.length;\n          const step = backoffScenario.sequence.find(s => s.step === attempt);\n          return [step?.httpStatus || 500, step?.response || step?.error];\n        });\n\n      await chaosSimulator.injectScenario(backoffScenario);\n\n      const publishRequest = {\n        workspaceId: 'ws-test-001',\n        platform: 'x',\n        content: { text: 'Backoff strategy test' }\n      };\n\n      const startTime = Date.now();\n      const result = await publisherAgent.publish(publishRequest);\n      const totalTime = Date.now() - startTime;\n\n      // Verify exponential backoff timing\n      expect(result.status).toBe('published');\n      expect(result.retries).toBe(3);\n      expect(totalTime).toBeGreaterThan(420000); // Should take at least 7 minutes\n      expect(totalTime).toBeLessThan(480000); // But not more than 8 minutes\n\n      // Verify backoff intervals increased exponentially\n      for (let i = 1; i < attemptTimes.length; i++) {\n        const interval = attemptTimes[i] - attemptTimes[i - 1];\n        const expectedMin = Math.pow(2, i - 1) * 60000 * 0.9; // With jitter tolerance\n        const expectedMax = Math.pow(2, i - 1) * 60000 * 1.1;\n        expect(interval).toBeGreaterThanOrEqual(expectedMin);\n        expect(interval).toBeLessThanOrEqual(expectedMax);\n      }\n    });\n  });\n\n  describe('Platform Outage Simulation', () => {\n    it('should handle complete platform outage with circuit breaker', async () => {\n      const outageScenario: FaultInjectionScenario = {\n        name: 'instagram-complete-outage',\n        platform: 'instagram',\n        sequence: [\n          { step: 1, httpStatus: 500, error: { code: 'INTERNAL_ERROR' }, delay: 0 },\n          { step: 2, httpStatus: 503, error: { code: 'SERVICE_UNAVAILABLE' }, delay: 1000 },\n          { step: 3, httpStatus: 502, error: { code: 'BAD_GATEWAY' }, delay: 2000 },\n          { step: 4, httpStatus: 504, error: { code: 'GATEWAY_TIMEOUT' }, delay: 5000 },\n          { step: 5, httpStatus: 500, error: { code: 'INTERNAL_ERROR' }, delay: 10000 }\n        ],\n        expectedBehavior: {\n          circuitBreakerTriggered: true,\n          platformMarkedDegraded: true,\n          alternativePlatformSuggested: true\n        }\n      };\n\n      nock('https://graph.facebook.com')\n        .persist()\n        .post('/me/media')\n        .replyWithError('ECONNREFUSED');\n\n      await chaosSimulator.injectScenario(outageScenario);\n\n      const publishRequest = {\n        workspaceId: 'ws-test-001',\n        platform: 'instagram',\n        content: {\n          media: [{ type: 'image', url: 'https://example.com/image.jpg' }],\n          caption: 'Circuit breaker test'\n        }\n      };\n\n      const result = await publisherAgent.publish(publishRequest);\n\n      // Verify circuit breaker activation\n      expect(result.status).toBe('circuit_breaker_open');\n      expect(result.circuitBreakerState).toBe('open');\n      expect(result.failureCount).toBeGreaterThanOrEqual(3);\n\n      // Verify platform status update\n      const connectorStatus = await connectorManager.getConnectorStatus('ws-test-001', 'instagram');\n      expect(connectorStatus.status).toBe('degraded');\n      expect(connectorStatus.lastFailure).toBeDefined();\n      expect(connectorStatus.circuitBreakerState).toBe('open');\n\n      // Verify decision card with alternative suggestions\n      const decisionCards = await decisionCardService.getByWorkspace('ws-test-001');\n      const outageCard = decisionCards.find(card => \n        card.recommendations.some(rec => rec.includes('platform_alternative'))\n      );\n      expect(outageCard).toBeDefined();\n      expect(outageCard?.metadata.affectedPlatform).toBe('instagram');\n      expect(outageCard?.metadata.suggestedAlternatives).toContain('facebook');\n    });\n\n    it('should recover gracefully when platform comes back online', async () => {\n      // First simulate outage\n      nock('https://api.linkedin.com')\n        .post('/v2/ugcPosts')\n        .times(3)\n        .reply(500, { error: 'Internal server error' });\n\n      const outageRequest = {\n        workspaceId: 'ws-test-001',\n        platform: 'linkedin',\n        content: { text: 'Test during outage' }\n      };\n\n      await publisherAgent.publish(outageRequest);\n\n      // Verify circuit breaker is open\n      let connectorStatus = await connectorManager.getConnectorStatus('ws-test-001', 'linkedin');\n      expect(connectorStatus.circuitBreakerState).toBe('open');\n\n      // Simulate platform recovery\n      nock.cleanAll();\n      nock('https://api.linkedin.com')\n        .post('/v2/ugcPosts')\n        .reply(200, {\n          id: 'urn:li:activity:7123456789',\n          publishedAt: '2024-01-15T10:35:00Z'\n        });\n\n      // Wait for circuit breaker timeout (mocked)\n      await chaosSimulator.advanceTime(60000); // Advance 1 minute\n\n      // Attempt publication again\n      const recoveryRequest = {\n        workspaceId: 'ws-test-001',\n        platform: 'linkedin',\n        content: { text: 'Test after recovery' }\n      };\n\n      const recoveryResult = await publisherAgent.publish(recoveryRequest);\n\n      // Verify successful recovery\n      expect(recoveryResult.status).toBe('published');\n      expect(recoveryResult.platformRecovered).toBe(true);\n\n      // Verify connector status updated\n      connectorStatus = await connectorManager.getConnectorStatus('ws-test-001', 'linkedin');\n      expect(connectorStatus.status).toBe('connected');\n      expect(connectorStatus.circuitBreakerState).toBe('closed');\n      expect(connectorStatus.lastSuccessfulPublish).toBeDefined();\n    });\n  });\n\n  describe('OAuth Token Management Chaos', () => {\n    it('should handle token refresh failure cascade', async () => {\n      const tokenChaosScenario: FaultInjectionScenario = {\n        name: 'oauth-token-refresh-cascade',\n        platform: 'linkedin',\n        sequence: [\n          {\n            step: 1,\n            endpoint: '/oauth/v2/accessToken',\n            httpStatus: 400,\n            error: {\n              code: 'INVALID_GRANT',\n              message: 'Refresh token expired'\n            }\n          },\n          {\n            step: 2,\n            endpoint: '/v2/ugcPosts',\n            httpStatus: 401,\n            error: {\n              code: 'UNAUTHORIZED',\n              message: 'Invalid access token'\n            }\n          }\n        ],\n        expectedBehavior: {\n          reauthorizationRequired: true,\n          userNotificationSent: true,\n          alternativeChannelActivated: true\n        }\n      };\n\n      // Mock OAuth token refresh failure\n      nock('https://www.linkedin.com')\n        .post('/oauth/v2/accessToken')\n        .reply(400, {\n          error: 'invalid_grant',\n          error_description: 'The provided refresh token is invalid or expired'\n        });\n\n      // Mock API call with invalid token\n      nock('https://api.linkedin.com')\n        .post('/v2/ugcPosts')\n        .reply(401, {\n          error: 'Unauthorized',\n          message: 'Invalid access token'\n        });\n\n      await chaosSimulator.injectScenario(tokenChaosScenario);\n\n      const publishRequest = {\n        workspaceId: 'ws-test-001',\n        platform: 'linkedin',\n        content: { text: 'OAuth failure test' }\n      };\n\n      const result = await publisherAgent.publish(publishRequest);\n\n      // Verify reauthorization workflow triggered\n      expect(result.status).toBe('reauthorization_required');\n      expect(result.authorizationUrl).toBeDefined();\n      expect(result.errorCode).toBe('OAUTH_REFRESH_FAILED');\n\n      // Verify user notification\n      const notifications = await connectorManager.getPendingNotifications('ws-test-001');\n      const authNotification = notifications.find(n => n.type === 'reauthorization_required');\n      expect(authNotification).toBeDefined();\n      expect(authNotification?.platform).toBe('linkedin');\n\n      // Verify decision card with reauthorization steps\n      const decisionCards = await decisionCardService.getByWorkspace('ws-test-001');\n      const authCard = decisionCards.find(card => \n        card.recommendations.some(rec => rec.includes('reauthorize_linkedin'))\n      );\n      expect(authCard).toBeDefined();\n      expect(authCard?.actionItems).toContain('complete_oauth_flow');\n    });\n  });\n\n  describe('Network Failure Simulation', () => {\n    it('should handle network timeouts and connection errors', async () => {\n      const networkChaosScenario: FaultInjectionScenario = {\n        name: 'network-instability',\n        platform: 'x',\n        sequence: [\n          { step: 1, networkError: 'ECONNRESET', delay: 0 },\n          { step: 2, networkError: 'ETIMEDOUT', delay: 5000 },\n          { step: 3, networkError: 'ENOTFOUND', delay: 10000 },\n          { step: 4, httpStatus: 200, response: { id: '1234567890' }, delay: 15000 }\n        ],\n        expectedBehavior: {\n          networkRetryStrategy: 'adaptive',\n          timeoutHandling: 'graceful',\n          connectionPooling: 'enabled'\n        }\n      };\n\n      // Simulate various network errors\n      nock('https://api.twitter.com')\n        .post('/2/tweets')\n        .times(3)\n        .replyWithError({ code: 'ECONNRESET', message: 'Connection reset by peer' })\n        .post('/2/tweets')\n        .reply(200, { data: { id: '1234567890', text: 'Network recovery test' } });\n\n      await chaosSimulator.injectScenario(networkChaosScenario);\n\n      const publishRequest = {\n        workspaceId: 'ws-test-001',\n        platform: 'x',\n        content: { text: 'Network instability test' },\n        retryConfig: {\n          maxRetries: 5,\n          timeoutMs: 10000,\n          backoffStrategy: 'adaptive'\n        }\n      };\n\n      const result = await publisherAgent.publish(publishRequest);\n\n      // Verify eventual success despite network issues\n      expect(result.status).toBe('published');\n      expect(result.networkRetries).toBe(3);\n      expect(result.totalLatency).toBeGreaterThan(15000);\n\n      // Verify adaptive retry strategy was used\n      expect(result.retryStrategy).toBe('adaptive');\n      expect(result.connectionPoolingUsed).toBe(true);\n    });\n  });\n});